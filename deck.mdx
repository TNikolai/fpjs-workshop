import { Image, Notes, Appear } from 'mdx-deck'
import { dark } from 'mdx-deck/themes'
import Layout, { Split } from './layout'
import codeSurfer from 'prism-react-renderer/themes/nightOwl'
export { components } from 'mdx-deck-code-surfer'
export const theme = {
  ...dark,
  codeSurfer,
  monospace: '"Dank Mono", "Fira Code", Consolas, "Roboto Mono", monospace',
  colors: {
    text: 'rgb(214, 222, 235)',
    code: 'rgb(130, 170, 255)',
    link: 'rgb(128, 203, 196)',
    background: 'rgb(1, 22, 39)',
  },
}

<Image src={require('file-loader!./img/lambda-background.png')} />

---

export default Layout

# λ Functional Programming Principles in JavaScript (a Workshop)

---

export default Layout

`λ -> putStrLn ("Hello, FP folks!")`

---

export default Layout

`https://github.com/kutyel/fpjs-workshop`

---

export default Layout

## Functors

<Appear>
  <p>
    <code>map :: Functor f => (a -> b) -> f a -> f b</code>
  </p>
  <p>
    <code>const map = curry((f, fx) => fx.map(f))</code>
  </p>
  <p>
    <strong>Identity law: </strong>
    <code>map(id) === id</code>
  </p>
  <p>
    <strong>Composition law: </strong>
    <code>compose(map(f), map(g)) === map(compose(f, g))</code>
  </p>
</Appear>

---

export default Layout

### `Functor` is all about function application! 🤯

<img src={require('file-loader!./img/functormap.png')} />

---

export default Layout

```js My First Functor
/**
 * Our first functor! 🎉
 */
const Box = x => ({
  map: f => Box(f(x)),
  inspect: () => `Box(${x})`,
})

Box.of = Box
----
* > Our first functor!
5 > This is the important part, the `map` function! 🗺
6 > This is for Node.js to let us see the inner value 👀
9 > `of` is just an optional constructor function
```

---

export default Layout

```js Things we can do with our Box
Box(2).map(two => two + 2)
// > Box(4)

Box('flamethrowers').map(s => s.toUpperCase())
// > Box(FLAMETHROWERS)

Box.of('bombs')
  .map(append(' away'))
  .map(prop('length'))
// > Box(10)
```

---

export default Layout

Our `Box` does nothing special... in fact it's called `Identity`!

---

export default Layout

### Famous Functors: Maybe

`data Maybe = Nothing | Just a`

---

export default Layout

```js Things we can do with Maybe
Maybe.of('Malkovich Malkovich').map(match(/a/gi))
// Just(True)

Maybe.of(null).map(match(/a/gi))
// Nothing

Maybe.of({ name: 'Boris' })
  .map(prop('age'))
  .map(add(10))
// Nothing

Maybe.of({ name: 'Dinah', age: 14 })
  .map(prop('age'))
  .map(add(10))
// Just(24)
```

---

export default Layout

```js
// safeHead :: [a] -> Maybe(a)
const safeHead = xs => Maybe.of(xs[0])

// streetName :: Object -> Maybe String
const streetName = compose(
  map(prop('street')),
  safeHead,
  prop('addresses')
)

streetName({ addresses: [] })
// > Nothing

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] })
// > Just('Shady Ln.')
```

---

export default Layout

```js Signaling failure
// withdraw :: Number -> Account -> Maybe(Account)
const withdraw = curry((amount, { balance }) =>
  Maybe.of(balance >= amount ? { balance: balance - amount } : null)
)

// This function is hypothetical, not implemented here... nor anywhere else.
// updateLedger :: Account -> Account
const updateLedger = account => account

// remainingBalance :: Account -> String
const remainingBalance = ({ balance }) => `Your balance is $${balance}`

// finishTransaction :: Account -> String
const finishTransaction = compose(
  remainingBalance,
  updateLedger
)

// getTwenty :: Account -> Maybe(String)
const getTwenty = compose(
  map(finishTransaction),
  withdraw(20)
)

getTwenty({ balance: 200.0 })
// Just('Your balance is $180')

getTwenty({ balance: 10.0 })
// Nothing
----
* > Let's have a look
1:4 > `withdraw` will tip its nose at us and return Nothing if we're short on cash
5:11 > some helper functions
12:17 > if the withdraw fails, then map will sever the rest of our computation
18:23 > this is the important bit
24:29 > it works as expected! 🎉
```

---

export default Layout

What if we want to find out why something failed with `Maybe`? 🤔

---

export default Layout

### Famous Functors: Either

`data Either = Left a | Right b`

---

export default Layout

```js
import Either from 'crocks/Either'

const { Left, Right } = Either

Either.of('rain').map(str => `b${str}`)
// Right('brain')

Left('rain').map(str => `It's gonna ${str}, better bring your umbrella!`)
// Left('rain')

Either.of({ host: 'localhost', port: 80 }).map(prop('host'))
// Right('localhost')

Left('rolls eyes...').map(prop('host'))
// Left('rolls eyes...')
```

---

export default Layout

```js
import Either from 'crocks/Either'
import moment from 'moment'

const { Left, Right } = Either

// getAge :: Date -> User -> Either(String, Number)
const getAge = curry((now, user) => {
  const birthDate = moment(user.birthDate, 'YYYY-MM-DD')

  return birthDate.isValid()
    ? Either.of(now.diff(birthDate, 'years'))
    : Left('Birth date could not be parsed')
})

getAge(moment(), { birthDate: '2005-12-12' })
// Right(9)

getAge(moment(), { birthDate: 'July 4, 2001' })
// Left('Birth date could not be parsed')
```

---

export default Layout

### Let's talk now about...

<Appear>
  <h1>Side Effects! 🙀</h1>
</Appear>

---

export default Layout

```js
// ioWindow :: IO Window
const ioWindow = IO.of(() => window)

ioWindow.map(win => win.innerWidth)
// IO(1430)

ioWindow
  .map(prop('location'))
  .map(prop('href'))
  .map(split('/'))
// IO(['http:', '', 'localhost:8000', 'blog', 'posts'])

// $ :: String -> IO [DOM]
const $ = selector => IO.of(() => document.querySelectorAll(selector))

$('#myDiv')
  .map(head)
  .map(div => div.innerHTML)
// IO('I am some inner html')
```

---

export default Layout

### Exercise time! 🏋🏼‍♂️

---

export default Layout

## Applicative Functors

<Appear>
  <p>
    <code>ap :: Applicative f => f (a -> b) -> f a -> f b</code>
  </p>
  <p>
    <strong>Identity law: </strong>
    <code>A.of(id).ap(v) === v</code>
  </p>
  <p>
    <strong>Composition law: </strong>
    <code>A.of(compose).ap(u).ap(v).ap(w) === u.ap(v.ap(w))</code>
  </p>
  <p>
    <strong>Homomorphism law: </strong>
    <code>A.of(f).ap(A.of(x)) === A.of(f(x))</code>
  </p>
  <p>
    <strong>Interchange law: </strong>
    <code>v.ap(A.of(x)) === A.of(f => f(x)).ap(v)</code>
  </p>
</Appear>

---

export default Layout

### Moar exercises! 🤸🏼‍♀️

---

export default Layout

## Monads

<Appear>
  <p>
    <code>flatMap :: Monad m => (a -> m b) -> m a -> m b</code>
  </p>
  <p>
    <code>const flatMap = curry((f, m) => m.map(f).join())</code>
  </p>
  <p>
    <code>const mcompose = (f, g) => compose(chain(f), g)</code>
  </p>
  <p>
    <strong>Left identity law: </strong>
    <code>mcompose(M, f) === f</code>
  </p>
  <p>
    <strong>Right identity law: </strong>
    <code>mcompose(f, M) === f</code>
  </p>
  <p>
    <strong>Associativity law: </strong>
    <code>mcompose(mcompose(f, g), h) === mcompose(f, mcompose(g, h))</code>
  </p>
</Appear>

---

export default Layout

### Last exercises! 🚀🚀🚀

---

export default Layout

# Thanks! 😸
